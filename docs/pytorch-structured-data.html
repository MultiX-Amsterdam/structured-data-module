
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>PyTorch Implementation (Structured Data Processing) &#8212; Structured Data Processing</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Optional Assignment (Structured Data Processing)" href="assignment-structured-data-optional.html" />
    <link rel="prev" title="Assignment (Structured Data Processing)" href="assignment-structured-data.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Structured Data Processing</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="overview-structured-data.html">
                    Structured Data Processing
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="preparation-structured-data.html">
   Preparation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tutorial-structured-data.html">
   Tutorial
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="assignment-structured-data.html">
   Assignment
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   PyTorch Implementation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="assignment-structured-data-optional.html">
   Optional Assignment
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://colab.research.google.com/github/MultiX-Amsterdam/structured-data-module/blob/main/docs/pytorch-structured-data.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Colab"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_colab.png">
  </span>
<span class="headerbtn__text-container">Colab</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/MultiX-Amsterdam/structured-data-module"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/MultiX-Amsterdam/structured-data-module/issues/new?title=Issue%20on%20page%20%2Fdocs/pytorch-structured-data.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/docs/pytorch-structured-data.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#your-task">
   Your Task
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>PyTorch Implementation (Structured Data Processing)</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#your-task">
   Your Task
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="pytorch-implementation-structured-data-processing">
<h1>PyTorch Implementation (Structured Data Processing)<a class="headerlink" href="#pytorch-implementation-structured-data-processing" title="Permalink to this headline">#</a></h1>
<p>(Last updated: Feb 12, 2024)<a class="footnote-reference brackets" href="#credit" id="id1">1</a></p>
<p>In this practice, we will guide you using the PyTorch deep learning framework to implement a deep regression model on the Smell Pittsburgh dataset. We only provide the basics in this notebook, and the following resources give more detailed information about PyTorch:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=wnKZZgFQY-E">Introduction to PyTorch (Part 1), UvA Deep Learning Course</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=schbjeU5X2g">Introduction to PyTorch (Part 2), UvA Deep Learning Course</a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">Deep Learning with PyTorch: A 60 Minute Blitz</a></p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>To make this notebook work, you need to <a class="reference external" href="https://pytorch.org/get-started/locally/">install PyTorch</a>. You can also copy this notebook (as well as the dataset) to Google Colab and run the notebook on it.</p>
</div>
<p>First, we begin importing the required packages.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">listdir</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
</pre></div>
</div>
</div>
</div>
<p>Then, we need to set the resources that we want to use for computing. On a machine with a GPU (Graphics Processing Unit), we would prefer to use it since a GPU can speed up the computation a lot. On a MacOS computer with advanced chips (e.g., M1 or M2), PyTorch can use the <a class="reference external" href="https://pytorch.org/docs/stable/notes/mps.html">MPS backend</a> to perform computing.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span> <span class="c1"># use CUDA device</span>
<span class="k">elif</span> <span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">mps</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;mps&quot;</span><span class="p">)</span> <span class="c1"># use MacOS GPU device (e.g., for M2 chips)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span> <span class="c1"># use CPU device</span>
<span class="n">device</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>device(type=&#39;mps&#39;)
</pre></div>
</div>
</div>
</div>
<p>The following code will help you move the data to the device that you choose.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_device</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Move PyTorch objects (e.g., tensors, models) to a chosen device&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">to_device</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">non_blocking</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Below we hide a bunch of functions for preprocessing the data. These functions are from the structured data processing tutorial.</p>
<div class="cell tag_hide-cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">answer_preprocess_sensor</span><span class="p">(</span><span class="n">df_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is the answer of task 5.</span>
<span class="sd">    Preprocess sensor data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_list : list of pandas.DataFrame</span>
<span class="sd">        A list of data frames that contain sensor data from multiple stations.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The preprocessed sensor data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Resample all the data frames.</span>
    <span class="n">df_resample_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_list</span><span class="p">:</span>
        <span class="c1"># Convert the timestamp to datetime.</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Resample the timestamps by hour and average all the previous values.</span>
        <span class="c1"># Because we want data from the past, so label need to be &quot;right&quot;.</span>
        <span class="n">df_resample_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;60Min&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

    <span class="c1"># Merge all data frames.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df_resample_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">index_name</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_resample_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># We need to use outer merging since we want to preserve data from both data frames.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_ordered</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df_resample_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Move the datetime column to index</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>

    <span class="c1"># Fill in the missing data with value -1.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">answer_preprocess_smell</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is the answer of task 4.</span>
<span class="sd">    Preprocess smell data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The raw smell reports data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The preprocessed smell data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy the dataframe to avoid editing the original one.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop the columns that we do not need.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;feelings_symptoms&quot;</span><span class="p">,</span> <span class="s2">&quot;smell_description&quot;</span><span class="p">,</span> <span class="s2">&quot;zipcode&quot;</span><span class="p">])</span>

    <span class="c1"># Select only the reports within the range of 3 and 5.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;smell_value&quot;</span><span class="p">]</span><span class="o">&gt;=</span><span class="mi">3</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;smell_value&quot;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">5</span><span class="p">)]</span>

    <span class="c1"># Convert the timestamp to datetime.</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">utc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Resample the timestamps by hour and sum up all the future values.</span>
    <span class="c1"># Because we want data from the future, so label need to be &quot;left&quot;.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="s2">&quot;60Min&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Fill in the missing data with value 0.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">answer_sum_current_and_future_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_hr</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is the answer of task 6.</span>
<span class="sd">    Sum up data in the current and future hours.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The preprocessed smell data.</span>
<span class="sd">    n_hr : int</span>
<span class="sd">         Number of hours that we want to sum up the future smell data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The transformed smell data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy data frame to prevent editing the original one.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Fast return if n_hr is 0</span>
    <span class="k">if</span> <span class="n">n_hr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">df</span>

    <span class="c1"># Sum up all smell_values in future hours.</span>
    <span class="c1"># The rolling function only works for summing up previous values.</span>
    <span class="c1"># So we need to shift back to get the value in the future.</span>
    <span class="c1"># Be careful that we need to add 1 to the rolling window size.</span>
    <span class="c1"># Becasue window size 1 means only using the current data.</span>
    <span class="c1"># Parameter &quot;closed&quot; need to be &quot;right&quot; because we want the current data.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">n_hr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">n_hr</span><span class="p">)</span>

    <span class="c1"># Below is an alternative implementation of rolling.</span>
    <span class="c1">#indexer = FixedForwardWindowIndexer(window_size=n_hr+1)</span>
    <span class="c1">#df = df.rolling(indexer, min_periods=1).sum()</span>

    <span class="c1"># Delete the last n_hr rows.</span>
    <span class="c1"># These n_hr rows have wrong data due to data shifting.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">n_hr</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">insert_previous_data_to_cols</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n_hr</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert columns to indicate the data from the previous hours.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The preprocessed sensor data.</span>
<span class="sd">    n_hr : int</span>
<span class="sd">        Number of hours that we want to insert the previous sensor data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The transformed sensor data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy data frame to prevent editing the original one.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add the data from the previous hours.</span>
    <span class="n">df_all</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_hr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Shift the data frame to get previous data.</span>
        <span class="n">df_pre</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="c1"># Edit the name to indicate it is previous data.</span>
        <span class="c1"># The orginal data frame already has data from the previous 1 hour.</span>
        <span class="c1"># (as indicated in the preprocessing phase of sensor data)</span>
        <span class="c1"># So we need to add 1 here.</span>
        <span class="n">df_pre</span><span class="o">.</span><span class="n">columns</span> <span class="o">+=</span> <span class="s2">&quot;_pre_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;h&quot;</span>
        <span class="c1"># Add the data to an array for merging.</span>
        <span class="n">df_all</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_pre</span><span class="p">)</span>

    <span class="c1"># Rename the columns in the original data frame.</span>
    <span class="c1"># The orginal data frame already has data from the previous 1 hour.</span>
    <span class="c1"># (as indicated in the preprocessing phase of sensor data)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">+=</span> <span class="s2">&quot;_pre_1h&quot;</span>

    <span class="c1"># Merge all data.</span>
    <span class="n">df_merge</span> <span class="o">=</span> <span class="n">df</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">df_all</span><span class="p">:</span>
        <span class="c1"># The join function merges dataframes by index.</span>
        <span class="n">df_merge</span> <span class="o">=</span> <span class="n">df_merge</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Delete the first n_hr rows.</span>
    <span class="c1"># These n_hr rows have no data due to data shifting.</span>
    <span class="n">df_merge</span> <span class="o">=</span> <span class="n">df_merge</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">n_hr</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">df_merge</span>


<span class="k">def</span> <span class="nf">convert_wind_direction</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert wind directions to sine and cosine components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The data frame that contains the wind direction data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        The transformed data frame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy data frame to prevent editing the original one.</span>
    <span class="n">df_cp</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Convert columns with wind directions.</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;SONICWD_DEG&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">df_c</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="n">df_c_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">df_c</span><span class="p">))</span>
            <span class="n">df_c_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">df_c</span><span class="p">))</span>
            <span class="n">df_c_cos</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">&quot;_cosine&quot;</span>
            <span class="n">df_c_sin</span><span class="o">.</span><span class="n">name</span> <span class="o">+=</span> <span class="s2">&quot;_sine&quot;</span>
            <span class="n">df_cp</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">df_cp</span><span class="p">[</span><span class="n">df_c_cos</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_c_cos</span>
            <span class="n">df_cp</span><span class="p">[</span><span class="n">df_c_sin</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_c_sin</span>
    <span class="k">return</span> <span class="n">df_cp</span>


<span class="k">def</span> <span class="nf">compute_feature_label</span><span class="p">(</span><span class="n">df_smell</span><span class="p">,</span> <span class="n">df_sensor</span><span class="p">,</span> <span class="n">b_hr_sensor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f_hr_smell</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute features and labels from the smell and sensor data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df_smell : pandas.DataFrame</span>
<span class="sd">        The preprocessed smell data.</span>
<span class="sd">    df_sensor : pandas.DataFrame</span>
<span class="sd">        The preprocessed sensor data.</span>
<span class="sd">    b_hr_sensor : int</span>
<span class="sd">        Number of hours that we want to insert the previous sensor data.</span>
<span class="sd">    f_hr_smell : int</span>
<span class="sd">        Number of hours that we want to sum up the future smell data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    df_x : pandas.DataFrame</span>
<span class="sd">        The features that we want to use for modeling.</span>
<span class="sd">    df_y : pandas.DataFrame</span>
<span class="sd">        The labels that we want to use for modeling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy data frames to prevent editing the original ones.</span>
    <span class="n">df_smell</span> <span class="o">=</span> <span class="n">df_smell</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="n">df_sensor</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Replace -1 values in sensor data to NaN</span>
    <span class="n">df_sensor</span><span class="p">[</span><span class="n">df_sensor</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Convert all wind directions.</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="n">convert_wind_direction</span><span class="p">(</span><span class="n">df_sensor</span><span class="p">)</span>

    <span class="c1"># Scale sensor data and fill in missing values</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_sensor</span> <span class="o">-</span> <span class="n">df_sensor</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">df_sensor</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="n">df_sensor</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="n">df_sensor</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Insert previous sensor data as features.</span>
    <span class="c1"># Noice that the df_sensor is already using the previous data.</span>
    <span class="c1"># So b_hr_sensor=0 means using data from the previous 1 hour.</span>
    <span class="c1"># And b_hr_sensor=n means using data from the previous n+1 hours.</span>
    <span class="n">df_sensor</span> <span class="o">=</span> <span class="n">insert_previous_data_to_cols</span><span class="p">(</span><span class="n">df_sensor</span><span class="p">,</span> <span class="n">b_hr_sensor</span><span class="p">)</span>

    <span class="c1"># Sum up current and future smell values as label.</span>
    <span class="c1"># Notice that the df_smell is already the data from the future 1 hour.</span>
    <span class="c1"># (as indicated in the preprocessing phase of smell data)</span>
    <span class="c1"># So f_hr_smell=0 means using data from the future 1 hour.</span>
    <span class="c1"># And f_hr_smell=n means using data from the future n+1 hours.</span>
    <span class="n">df_smell</span> <span class="o">=</span> <span class="n">answer_sum_current_and_future_data</span><span class="p">(</span><span class="n">df_smell</span><span class="p">,</span> <span class="n">f_hr_smell</span><span class="p">)</span>

    <span class="c1"># Add suffix to the column name of the smell data to prevent confusion.</span>
    <span class="c1"># See the description above for the reason of adding 1 to the f_hr_smell.</span>
    <span class="n">df_smell</span><span class="o">.</span><span class="n">columns</span> <span class="o">+=</span> <span class="s2">&quot;_future_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">f_hr_smell</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;h&quot;</span>

    <span class="c1"># We need to first merge these two timestamps based on the available data.</span>
    <span class="c1"># In this way, we synchronize the time stamps in the sensor and smell data.</span>
    <span class="c1"># This also means that the sensor and smell data have the same number of data points.</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_ordered</span><span class="p">(</span><span class="n">df_sensor</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span> <span class="n">df_smell</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span> <span class="n">on</span><span class="o">=</span><span class="n">df_smell</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Sanity check: there should be no missing data.</span>
    <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error! There is missing data.&quot;</span>

    <span class="c1"># Separate features (x) and labels (y).</span>
    <span class="n">df_x</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_sensor</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">df_y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df_smell</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Add the hour of day and the day of week.</span>
    <span class="n">dow_radian</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;EpochTime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">dayofweek</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">6.0</span>
    <span class="n">tod_radian</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;EpochTime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">23.0</span>
    <span class="n">df_x</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;day_of_week_sine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dow_radian</span><span class="p">)</span>
    <span class="n">df_x</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;day_of_week_cosine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dow_radian</span><span class="p">)</span>
    <span class="n">df_x</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;hour_of_day_sine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tod_radian</span><span class="p">)</span>
    <span class="n">df_x</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s2">&quot;hour_of_day_cosine&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">tod_radian</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_x</span><span class="p">,</span> <span class="n">df_y</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we need to load and preprocess the dataset using the code in the structured data processing tutorial.</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load and preprocess sensor data</span>
<span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;smellpgh-v1/esdr_raw&quot;</span>
<span class="n">list_of_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="p">))]</span>
<span class="n">sensor_raw_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">list_of_files</span><span class="p">:</span>
    <span class="n">sensor_raw_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;EpochTime&quot;</span><span class="p">))</span>
<span class="n">df_sensor</span> <span class="o">=</span> <span class="n">answer_preprocess_sensor</span><span class="p">(</span><span class="n">sensor_raw_list</span><span class="p">)</span>

<span class="c1"># Load and preprocess smell data</span>
<span class="n">smell_raw</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;smellpgh-v1/smell_raw.csv&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;EpochTime&quot;</span><span class="p">)</span>
<span class="n">df_smell</span> <span class="o">=</span> <span class="n">answer_preprocess_smell</span><span class="p">(</span><span class="n">smell_raw</span><span class="p">)</span>

<span class="c1"># Compute features and labels</span>
<span class="n">df_x</span><span class="p">,</span> <span class="n">df_y</span> <span class="o">=</span> <span class="n">compute_feature_label</span><span class="p">(</span><span class="n">df_smell</span><span class="p">,</span> <span class="n">df_sensor</span><span class="p">,</span> <span class="n">b_hr_sensor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">f_hr_smell</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Use value 40 as the threshold to indicate a smell event</span>
<span class="c1"># In this way, we make it a binary classification problem</span>
<span class="n">df_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_y</span><span class="o">&gt;=</span><span class="mi">40</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df_x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>3.feed_1.SO2_PPM_pre_1h</th>
      <th>3.feed_1.H2S_PPM_pre_1h</th>
      <th>3.feed_1.SIGTHETA_DEG_pre_1h</th>
      <th>3.feed_1.SONICWS_MPH_pre_1h</th>
      <th>3.feed_23.CO_PPM_pre_1h</th>
      <th>3.feed_23.PM10_UG_M3_pre_1h</th>
      <th>3.feed_29.PM10_UG_M3_pre_1h</th>
      <th>3.feed_29.PM25_UG_M3_pre_1h</th>
      <th>3.feed_11067.CO_PPB..3.feed_43.CO_PPB_pre_1h</th>
      <th>3.feed_11067.NO2_PPB..3.feed_43.NO2_PPB_pre_1h</th>
      <th>...</th>
      <th>3.feed_28.SONICWD_DEG_cosine_pre_3h</th>
      <th>3.feed_28.SONICWD_DEG_sine_pre_3h</th>
      <th>3.feed_26.SONICWD_DEG_cosine_pre_3h</th>
      <th>3.feed_26.SONICWD_DEG_sine_pre_3h</th>
      <th>3.feed_3.SONICWD_DEG_cosine_pre_3h</th>
      <th>3.feed_3.SONICWD_DEG_sine_pre_3h</th>
      <th>day_of_week_sine</th>
      <th>day_of_week_cosine</th>
      <th>hour_of_day_sine</th>
      <th>hour_of_day_cosine</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>-1.520058</td>
      <td>-0.599075</td>
      <td>-0.388936</td>
      <td>-0.777225</td>
      <td>-0.406466</td>
      <td>-0.395826</td>
      <td>-0.716551</td>
      <td>-0.585693</td>
      <td>...</td>
      <td>0.279097</td>
      <td>1.746934</td>
      <td>-0.383942</td>
      <td>1.929446</td>
      <td>-0.542867</td>
      <td>1.331119</td>
      <td>0.000000</td>
      <td>1.0</td>
      <td>-2.449294e-16</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>-1.433654</td>
      <td>-0.684709</td>
      <td>-0.388936</td>
      <td>-0.690974</td>
      <td>0.007500</td>
      <td>-0.305936</td>
      <td>-0.426597</td>
      <td>0.488014</td>
      <td>...</td>
      <td>1.089779</td>
      <td>1.481480</td>
      <td>0.945548</td>
      <td>1.350182</td>
      <td>0.512949</td>
      <td>1.355712</td>
      <td>0.866025</td>
      <td>0.5</td>
      <td>0.000000e+00</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>1.142731</td>
      <td>-0.941610</td>
      <td>0.147335</td>
      <td>-0.173473</td>
      <td>-0.147737</td>
      <td>-0.216045</td>
      <td>-0.444787</td>
      <td>0.829648</td>
      <td>...</td>
      <td>0.799733</td>
      <td>1.640186</td>
      <td>0.726159</td>
      <td>1.603583</td>
      <td>0.537757</td>
      <td>1.347897</td>
      <td>0.866025</td>
      <td>0.5</td>
      <td>2.697968e-01</td>
      <td>0.962917</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>-0.082623</td>
      <td>-0.941610</td>
      <td>0.147335</td>
      <td>-0.432224</td>
      <td>-0.302974</td>
      <td>-0.216045</td>
      <td>-0.796641</td>
      <td>0.081306</td>
      <td>...</td>
      <td>0.960380</td>
      <td>1.562966</td>
      <td>1.185067</td>
      <td>0.816616</td>
      <td>0.512949</td>
      <td>1.355712</td>
      <td>0.866025</td>
      <td>0.5</td>
      <td>5.195840e-01</td>
      <td>0.854419</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>1.527618</td>
      <td>-0.984426</td>
      <td>0.147335</td>
      <td>-0.259723</td>
      <td>-0.458211</td>
      <td>-0.485717</td>
      <td>-0.762976</td>
      <td>-0.504352</td>
      <td>...</td>
      <td>1.623480</td>
      <td>0.780539</td>
      <td>1.225168</td>
      <td>0.602477</td>
      <td>0.659294</td>
      <td>1.303117</td>
      <td>0.866025</td>
      <td>0.5</td>
      <td>7.308360e-01</td>
      <td>0.682553</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>16746</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>0.011635</td>
      <td>-0.128090</td>
      <td>-0.925207</td>
      <td>-0.604724</td>
      <td>-0.561703</td>
      <td>-0.575607</td>
      <td>0.529598</td>
      <td>-0.748376</td>
      <td>...</td>
      <td>1.707841</td>
      <td>0.380565</td>
      <td>1.119099</td>
      <td>-0.254164</td>
      <td>1.210281</td>
      <td>-0.738344</td>
      <td>-0.866025</td>
      <td>0.5</td>
      <td>-9.976688e-01</td>
      <td>-0.068242</td>
    </tr>
    <tr>
      <th>16747</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>0.443651</td>
      <td>0.000361</td>
      <td>-0.925207</td>
      <td>-0.690974</td>
      <td>-0.406466</td>
      <td>-0.665498</td>
      <td>0.662087</td>
      <td>-0.292864</td>
      <td>...</td>
      <td>1.693445</td>
      <td>0.048275</td>
      <td>1.098706</td>
      <td>-0.303805</td>
      <td>1.327922</td>
      <td>-0.583204</td>
      <td>-0.866025</td>
      <td>0.5</td>
      <td>-9.790841e-01</td>
      <td>0.203456</td>
    </tr>
    <tr>
      <th>16748</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>0.443651</td>
      <td>-0.256540</td>
      <td>-0.925207</td>
      <td>-0.604724</td>
      <td>-0.458211</td>
      <td>-0.575607</td>
      <td>0.181817</td>
      <td>-0.862254</td>
      <td>...</td>
      <td>1.489886</td>
      <td>-0.500401</td>
      <td>0.609087</td>
      <td>-0.931955</td>
      <td>0.798657</td>
      <td>-1.062282</td>
      <td>-0.866025</td>
      <td>0.5</td>
      <td>-8.878852e-01</td>
      <td>0.460065</td>
    </tr>
    <tr>
      <th>16749</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>0.270844</td>
      <td>-0.085273</td>
      <td>-0.925207</td>
      <td>-0.518474</td>
      <td>-0.302974</td>
      <td>-0.575607</td>
      <td>0.856204</td>
      <td>-0.439279</td>
      <td>...</td>
      <td>1.402368</td>
      <td>-0.626362</td>
      <td>0.237194</td>
      <td>-1.124325</td>
      <td>0.706601</td>
      <td>-1.107672</td>
      <td>-0.866025</td>
      <td>0.5</td>
      <td>-7.308360e-01</td>
      <td>0.682553</td>
    </tr>
    <tr>
      <th>16750</th>
      <td>-0.273112</td>
      <td>-0.403688</td>
      <td>-0.341833</td>
      <td>0.085995</td>
      <td>-0.925207</td>
      <td>-0.432224</td>
      <td>-0.406466</td>
      <td>-0.395826</td>
      <td>0.798647</td>
      <td>-0.309133</td>
      <td>...</td>
      <td>0.581575</td>
      <td>-1.153330</td>
      <td>-0.684058</td>
      <td>-1.060369</td>
      <td>-0.161757</td>
      <td>-1.243870</td>
      <td>-0.866025</td>
      <td>0.5</td>
      <td>-5.195840e-01</td>
      <td>0.854419</td>
    </tr>
  </tbody>
</table>
<p>16751 rows × 148 columns</p>
</div></div></div>
</div>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df_y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>smell_value_future_8h</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
    </tr>
    <tr>
      <th>16746</th>
      <td>0</td>
    </tr>
    <tr>
      <th>16747</th>
      <td>0</td>
    </tr>
    <tr>
      <th>16748</th>
      <td>0</td>
    </tr>
    <tr>
      <th>16749</th>
      <td>0</td>
    </tr>
    <tr>
      <th>16750</th>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>16751 rows × 1 columns</p>
</div></div></div>
</div>
<p>We now have the dataset ready in Pandas. To make it work for PyTorch, we need to first convert the <code class="docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code> object to a <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code> object with the <code class="docutils literal notranslate"><span class="pre">torch.float32</span></code> data type (because our PyTorch model will take this data type as the input). The PyTorch tensor object is similar to <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> but with more functions to support GPU (Graphics Processing Unit) computing. GPU can perform matrix operations much more efficiently than CPU (Central Processing Unit), and people usually use PyTorch to benefit from its powerful GPU computing support. The following code does the conversion. For more information about tensors, check this <a class="reference external" href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial2/Introduction_to_PyTorch.html#Tensors">UvA deep learning tutorial</a> and this <a class="reference external" href="https://pytorch.org/tutorials/beginner/introyt/tensors_deeper_tutorial.html">PyTorch documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert pandas.DataFrame to torch.Tensor with type torch.float32</span>
<span class="n">feature</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">df_x</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">df_y</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we need to create a <code class="docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code> class, which is a uniform interface for loading data. More description about the PyTorch dataset class can be found in this <a class="reference external" href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial2/Introduction_to_PyTorch.html#The-dataset-class">UvA deep learning tutorial</a> and this <a class="reference external" href="https://pytorch.org/tutorials/beginner/data_loading_tutorial.html#dataset-class">PyTorch documentation</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SmellPittsburghDataset</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature</span> <span class="o">=</span> <span class="n">feature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">feature</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>We can use the dataset to create a training and validation set. In the code below, we use the first 8000 data points as the training set, followed by 168 data points as the validation set. We will use the training set to train the model and the validation set for evaluating model performance. In this case, 8000 data points mean 8000 hours, which is about 11 months in real-world time, and 168 data points represent about 7 days of time. The reason for doing this kind of split is because Smell Pittsburgh is a time-series dataset, which means we should use data from the past to predict the outcome in the future, but not the other way around.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_size</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="n">validation_size</span> <span class="o">=</span> <span class="mi">168</span>
<span class="n">test_size</span> <span class="o">=</span> <span class="mi">168</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">8000</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">168</span>
<span class="n">dataset_train</span> <span class="o">=</span> <span class="n">SmellPittsburghDataset</span><span class="p">(</span><span class="n">feature</span><span class="o">=</span><span class="n">feature</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
<span class="n">dataset_validation</span> <span class="o">=</span> <span class="n">SmellPittsburghDataset</span><span class="p">(</span><span class="n">feature</span><span class="o">=</span><span class="n">feature</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">k</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Then, let us define a scoring function to evaluate the model performance for binary classification. The function takes two inputs: one is the array of predicted labels, and the other one is the true labels. In this case, we use precision, recall, and F1 score. Notice that we do a small trick here to return empty arrays of the output when the input is <code class="docutils literal notranslate"><span class="pre">None</span></code>, which will be handy later when we need to keep appending the scores into arrays of metrics.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binary_scorer</span><span class="p">(</span><span class="n">y_predict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A customized scoring function to evaluate a binary classifier.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y_predict : torch.Tensor</span>
<span class="sd">        The predicted binary labels in 0 (negative) or 1 (positive).</span>
<span class="sd">    y : torch.Tensor</span>
<span class="sd">        The true binary labels in 0 (negative) or 1 (positive).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict of int or float</span>
<span class="sd">        A dictionary of evaluation metrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y_predict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Compute metrics and return them</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_predict</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="p">(</span><span class="n">eq</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_predict</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="p">(</span><span class="n">eq</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_predict</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_predict</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_predict</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">tpfp</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">fp</span>
        <span class="n">tpfn</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">tpfp</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">tpfp</span><span class="p">)</span>
        <span class="n">recall</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">tpfn</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">tpfn</span><span class="p">)</span>
        <span class="n">fscore</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">precision</span><span class="o">+</span><span class="n">recall</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">precision</span><span class="o">*</span><span class="n">recall</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">precision</span><span class="o">+</span><span class="n">recall</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="n">precision</span><span class="p">,</span> <span class="s2">&quot;recall&quot;</span><span class="p">:</span> <span class="n">recall</span><span class="p">,</span> <span class="s2">&quot;fscore&quot;</span><span class="p">:</span> <span class="n">fscore</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return the structure of the dictionary with empty arrays for initialization</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;recall&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;fscore&quot;</span><span class="p">:</span> <span class="p">[]}</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we need to train the model for multiple epochs, which means running through all the available data multiple times in the training set. Different from the traditional gradient descent, deep learning models use <a class="reference external" href="http://d2l.ai/chapter_optimization/minibatch-sgd.html">Stochastic Gradient Descent (SGD) with mini-batches</a>, which takes batches of data points (instead of all data). For more information about SGD, check <a class="reference external" href="https://www.youtube.com/watch?v=vMh0zPT0tLI">this StatQuest video</a>.</p>
<p>The reason for using mini-batch SGD is because training supervised deep learning models typically requires a lot of data (i.e., this is called many-shot learning now), and it is often impossible to fit all data into computer memory, so we have to feed the data to the optimization algorithm in batches. Also, training deep learning models usually requires going through all data points multiple times (i.e., multiple epochs). Batch size is a hyperparameter for tuning.</p>
<p>Now let us create a <code class="docutils literal notranslate"><span class="pre">torch.utils.data.DataLoader</span></code> object, which is a way to load data efficiently and is extremely beneficial if you cannot fit all data into computer memory at once (e.g., a bunch of videos). More information about DataLoader can be found in this <a class="reference external" href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial2/Introduction_to_PyTorch.html#The-data-loader-class">UvA deep learning tutorial</a> or this <a class="reference external" href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html#preparing-your-data-for-training-with-dataloaders">PyTorch documentation</a>. The DataLoader object also allows us to load data in batches by specifying the batch size. Notice that we only want to shuffle the training set here, not the validation set.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>When writing PyTorch code for training deep learning models, the first important thing is to get <code class="docutils literal notranslate"><span class="pre">torch.utils.data.Dataset</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.utils.data.DataLoader</span></code> objects ready.</p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dataloader_train</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset_train</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">168</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">dataloader_validation</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset_validation</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">168</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>To allow the DataLoader to use the device that we specified at the beginning of this notebook, we need to use the following code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DeviceDataLoader</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Wrap a dataloader to move data to a chosen device&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">device</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dl</span> <span class="o">=</span> <span class="n">dl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span>
        
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield a batch of data after moving it to device&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">to_device</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of batches&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now, we can move the DataLoader objects to the specified device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dataloader_train</span> <span class="o">=</span> <span class="n">DeviceDataLoader</span><span class="p">(</span><span class="n">dataloader_train</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
<span class="n">dataloader_validation</span> <span class="o">=</span> <span class="n">DeviceDataLoader</span><span class="p">(</span><span class="n">dataloader_validation</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we need to define the deep regression model. We use two layers of linear neurons. The first layer maps the features to 64 hidden units (i.e., linear neurons), and the second layer maps 64 hidden units to one single output (i.e., whether there is a smell event or not).</p>
<p>Notice that for computational efficiency, we do not need to ensure that the output is probability since the loss function that we will define later already does this job for us (i.e., the <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html">torch.nn.BCEWithLogitsLoss</a>). We only need to make sure that it is probability later when we are going to use the model to make predictions of events for our task.</p>
<p>In the forward function, we define how the network will pass the result from each layer to the next layer. We use the ReLU activation function between the first and second layers to introduce some non-linearity. We do not need to define a backward function since PyTorch can automatically compute and backpropagate the gradients for us to iteratively update the model weights.</p>
<p>In this case, we choose to use 64 hidden units for demonstration purposes. In reality, this is a hyperparameter that you can tune. The input size should match the number of features (otherwise, running the code will give an error).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DeepRegression</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">output_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DeepRegression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">hidden_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</div>
</div>
<p>We are getting close to being able to train the model. The last three things that we need are to create the model object, specify the loss function (for the optimization algorithm to compute the error so that PyTorch can compute and backpropagate the gradients to update the model weights), and define the optimizer (i.e., the optimization algorithm).</p>
<p>Regarding the model, the code above defines a class. To be able to use it, we need to use the class to create an object. Think about a class as a design specification (e.g., spec for a car) and an object as producing the real design artifact (e.g., a real car). Regarding the loss criterion, we use the <a class="reference external" href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial2/Introduction_to_PyTorch.html#Loss-modules">Binary Cross Entropy (BCE) loss function</a>, which is standard for binary classification. Notice that we are not using <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.BCELoss.html">torch.nn.BCELoss</a> for computational efficiency. The <a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html">torch.nn.BCEWithLogitsLoss</a> that we use instead here can take care of the job of transforming the output of the final neural network layer into probabilities.</p>
<p>Regarding the optimizer, we use the <a class="reference external" href="https://arxiv.org/pdf/1412.6980.pdf">Adam optimization algorithm</a>, which is a variation of Stochastic Gradient Descent with advanced capabilities in scheduling learning rates and scaling the gradients dynamically. Here, we use <code class="docutils literal notranslate"><span class="pre">0.0005</span></code> as the learning rate and <code class="docutils literal notranslate"><span class="pre">0.0001</span></code> as the weight decay for regularization. Adding the regularization can make the training more stable and prevent overfitting. In reality, they are hyperparameters for tuning.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DeepRegression</span><span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">to_device</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span> <span class="c1"># move the model to the specified device</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can use the following function to train the model for multiple epochs and return the model performance metrics. We will use the <a class="reference external" href="https://tqdm.github.io/"><code class="docutils literal notranslate"><span class="pre">tqdm</span></code> package</a> for help in tracking the progress in the for-loop, which is handy for deep learning code that can take a long time to run.</p>
<p>As mentioned before, the output of the model is not probability for computational efficiency. But when computing the model performance, we need the probability to determine how likely there will be smell events. We will use the Sigmoid function to convert the output from the final layer to probabilities that sum up to one. Then, we can check if the probability is larger than a threshold (e.g., 0.5).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Train a PyTorch model and print model performance metrics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataloader : torch.utils.data.DataLoader</span>
<span class="sd">        The dataloader object.</span>
<span class="sd">    model : torch.nn.Module</span>
<span class="sd">        The PyTorch model that we want to train.</span>
<span class="sd">    criterion : torch.nn.modules.loss._Loss</span>
<span class="sd">        The loss function.</span>
<span class="sd">    optimizer : torch.optim.Optimizer</span>
<span class="sd">        The optimization algorithm.</span>
<span class="sd">    num_epochs : int</span>
<span class="sd">        Number of epochs for training the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span> <span class="c1"># set the model to training mode</span>
    <span class="c1"># Loop epochs</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">)):</span>
        <span class="n">score_arrays</span> <span class="o">=</span> <span class="n">binary_scorer</span><span class="p">()</span> <span class="c1"># get the empty structure</span>
        <span class="n">score_arrays</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># add the field for appending the loss</span>
        <span class="c1"># Loop the dataloader</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># make predictions using the model</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># compute the loss</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span> <span class="c1"># set initial gradients to zero</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span> <span class="c1"># accumulate and backpropagate the gradients</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span> <span class="c1"># update model weights</span>
            <span class="n">score_arrays</span><span class="p">[</span><span class="s2">&quot;loss&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">())</span> <span class="c1"># append the loss</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="c1"># turn model output into probabilities</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pred</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span> <span class="c1"># turn probabilities to labels with 0 or 1</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">binary_scorer</span><span class="p">(</span><span class="n">y_label</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># compute evaluation metrics</span>
            <span class="c1"># Append the evaluation metrics to the arrays</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">score</span><span class="p">:</span>
                <span class="n">score_arrays</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="c1"># After every 10 epochs, print the averaged evaluation metrics</span>
        <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epoch </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">epoch</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">score_arrays</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;averaged training </span><span class="si">%s</span><span class="s2">: </span><span class="si">%4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score_arrays</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we need a function to evaluate the model on the valiation or test set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">evaluate_model</span><span class="p">(</span><span class="n">dataloader</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a PyTorch model and print model performance metrics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataloader : torch.utils.data.DataLoader</span>
<span class="sd">        The dataloader object.</span>
<span class="sd">    model : torch.nn.Module</span>
<span class="sd">        The PyTorch model that we want to train.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span> <span class="c1"># set the model to evaluation mode</span>
    <span class="c1"># Since we do not want to train the model, make sure that we deactivate the gradients</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="n">score_arrays</span> <span class="o">=</span> <span class="n">binary_scorer</span><span class="p">()</span> <span class="c1"># get the empty structure</span>
        <span class="c1"># Loop the dataloader</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># make predictions using the model</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span> <span class="c1"># turn model output into probabilities</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pred</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span> <span class="c1"># turn probabilities to labels with 0 or 1</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">binary_scorer</span><span class="p">(</span><span class="n">y_label</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># compute evaluation metrics</span>
            <span class="c1"># Append the evaluation metrics to the arrays</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">score</span><span class="p">:</span>
                <span class="n">score_arrays</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="c1"># Print the averaged evaluation metrics</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Validate model performance:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">score_arrays</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;averaged validation </span><span class="si">%s</span><span class="s2">: </span><span class="si">%4f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">score_arrays</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we can now run the functions to train the model for 30 epochs and evaluate the model on the validation set. In practice, you can run the model for many epochs, save the model for every X epochs (e.g., X=5), and pick the model with the highest performance on the validation set.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_model</span><span class="p">(</span><span class="n">dataloader_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">evaluate_model</span><span class="p">(</span><span class="n">dataloader_train</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  7%|██▏                             | 2/30 [00:00&lt;00:06,  4.05it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>========================================
Epoch 0
averaged training precision: 0.347569
averaged training recall: 0.050568
averaged training fscore: 0.085399
averaged training loss: 0.410165
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 37%|███████████▎                   | 11/30 [00:02&lt;00:03,  4.80it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>========================================
Epoch 10
averaged training precision: 0.853211
averaged training recall: 0.377262
averaged training fscore: 0.508721
averaged training loss: 0.137110
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> 70%|█████████████████████▋         | 21/30 [00:04&lt;00:01,  4.84it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>========================================
Epoch 20
averaged training precision: 0.892700
averaged training recall: 0.480476
averaged training fscore: 0.614713
averaged training loss: 0.109115
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100%|███████████████████████████████| 30/30 [00:06&lt;00:00,  4.76it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>========================================
========================================
Validate model performance:
averaged validation precision: 0.953974
averaged validation recall: 0.553031
averaged validation fscore: 0.687117
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<section id="your-task">
<h2>Your Task<a class="headerlink" href="#your-task" title="Permalink to this headline">#</a></h2>
<p>We have used the deep regression model to perform smell event classification on the Smell Pittsburgh dataset. Now, your task is to implement cross-validation (similar to the one that is used in the structured data processing tutorial) and perform hyperparameter tuning. Write your code below and print the averaged precision, recall, and F1 score after performing cross-validation and hyperparameter tuning. There are four hyperparameters that you can tune: the hidden unit size of the model, learning rate, weight decay, and batch size.</p>
<p>Notice that you also need to allocate a test set to have a more objective estimation of model performance. The test set cannot be seen by the model during hyperparameter tuning. Report also the precision, recall, and F1 score for the test set.</p>
<p>Optionally, you can also change the model architecture, such as adding more layers or changing the activation function. Have fun playing with deep learning models!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Write your code here</span>
</pre></div>
</div>
</div>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="credit"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Credit: this teaching material is created by <a class="reference external" href="https://github.com/yenchiah">Yen-Chia Hsu</a>.</p>
</dd>
</dl>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./docs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="assignment-structured-data.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Assignment (Structured Data Processing)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="assignment-structured-data-optional.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Optional Assignment (Structured Data Processing)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Yen-Chia Hsu<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>